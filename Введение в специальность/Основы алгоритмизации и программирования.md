## Управление компьютером при помощи программ: Теоретическая основа и архитектура

**Компьютер**, как универсальная вычислительная машина (по определению [[Алан Тьюринг|Алана Тьюринга]]) представляет собой устройство, способное выполнять произвольные алгоритмы при наличии подходящей программы. #Компьютер

**Программа** - формализованная последовательность инструкций, предназначенная для управления ресурсами ЭВМ (в данном случае, компьютера). В научном смысле, управление при помощи программ реализуется через машинную модель Джона фон Неймана, где программы и данные хранятся в единой памяти, а процессор последовательно интерпретирует команды. #Программа

С точки зрения архитектуры, программа сначала загружается в оперативную память, затем извлекается для выполнения, декодируется и исполняется процессором. Взаимодействие с программой осуществляется при помощи устройств ввода/вывода.
### Роль ОС
ОС выступает как посредник, абстрагируя аппаратные детали, лишь предоставляя интерфейсы ограниченного взаимодействия с ними. В терминах теории систем, ОС реализует виртуализацию ресурсов, позволяя нескольким программам работать параллельно.
### Вывод
Без программ компьютер остается пассивным устройством, а программы наделяют его "интеллектом" через детерминированное выполнение. На данный момент, именно пользователь, отталкиваясь от задачи, определяет исполнителя и его характеристики.
## Понятие алгоритма: формальное определение и свойства
Алгоритм - абстрактная логически-математическая конструкция, представляющая собой конечную последовательность строго определенных шагов, приводящих от начального состояния (входных данных) к желаемому результату (выходным данным). Сам термин происходит от латинской транслитерации имени персидского математика Мухаммеда аль-Хорезми, жившего в 9 веке. Его труды заложили основу систематического решения уравнений.
### Основные свойства алгоритма
#Свойства-алгоритма
1. Детерминированность (однозначность)
   Каждый шаг определяет уникальное действие для данного состояния.
2. Массовость (общность)
   Алгоритм применим к классу задач, а не к одной конкретной.
3. Результативность (эффективность)
   Гарантирует получение корректного результата.
4. Дискретность
   Возможность разбиения алгоритма на атомарные (примитивные) операции.
5. Конечность
   Любой алгоритм завершается за конечное число шагов.
6. Корректность
   Результат соответствует ожидаемому и может быть проверен (доказан).

Также, алгоритмы поддаются следующему анализу:
- Временная сложность (ВС)
  Мера количества вычислительных ресурсов (времени), необходимых для выполнения алгоритма в зависимости от входных данных.
- Пространственная сложность (ПС)
  Мера объема памяти, необходимого для выполнения алгоритма и выраженная, как функция от размера входных данных. 
- Средний случай

## Big-O Notation
![[BIG-O.jpg]]
**Big O** — это математическая нотация, которая описывает **предельное поведение функции** при росте аргумента. В программировании и алгоритмах она используется для описания **временной** и **пространственной** сложности алгоритмов в худшем случае. #Big-O

Проще говоря, Big O показывает, как время выполнения или потребление памяти алгоритма растет с увеличением объема входных данных (n).

---
### Основные сложности (от лучшей к худшей)
**O(1)** — Константная сложность
* Время выполнения не зависит от размера входных данных.
* **Пример:** Доступ к элементу массива по индексу.
  
**O(log n)** — Логарифмическая сложность
* Время выполнения растет логарифмически от размера входных данных. Очень эффективно для больших данных.
* **Пример:** Бинарный поиск.

**O(n)** — Линейная сложность
* Время выполнения растет прямо пропорционально размеру входных данных.
* **Пример:** Поиск в неотсортированном массиве (линейный поиск).

**O(n log n)** — Линейно-логарифмическая сложность
* Характерна для эффективных алгоритмов сортировки.
* **Пример:** Сортировка слиянием, быстрая сортировка (в среднем случае).

**O(n²)** — Квадратичная сложность
* Время выполнения пропорционально квадрату размера входных данных. Типично для простых алгоритмов с вложенными циклами.
* **Пример:** Сортировка пузырьком, выбором, вставкой.

**O(2ⁿ)** — Экспоненциальная сложность
* Время выполнения удваивается с каждым добавлением новой входной данных. Крайне неэффективно.
* **Пример:** Рекурсивное вычисление чисел Фибоначчи (наивная реализация).

**O(n!)** — Факториальная сложность
* Время выполнения растет факториально. Самый плохой вариант.
* **Пример:** Решение задачи коммивояжера полным перебором.

---
### Ключевые принципы анализа
Рассматриваем худший случай (Upper Bound).
Отбрасываем константы: O(2n) -> O(n).
Отбрасываем неглавные слагаемые: O(n² + n) -> O(n²).
Анализируется асимптотическое поведение (при стремлении n к бесконечности).
### Зачем это нужно?
Big O позволяет объективно **сравнивать алгоритмы** между собой и предсказывать, как они будут вести себя на больших объемах данных, что критически важно для создания производительных приложений.
## Классификация по структуре
#Типы-алгоритмов
1. Линейные, которые выполняются последовательно.
2. С ветвлением, например, условные конструкции.
3. Циклические, в которых задействованы повторения.
4. Рекурсивные, в которых происходит обращение алгоритма к самому себе.